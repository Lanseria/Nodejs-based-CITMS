%%================================================
%% Filename: chap04.tex
%% Encoding: UTF-8
%% Author: Yuan Xiaoshuai - yxshuai@gmail.com
%% Created: 2012-04-28 00:15
%% Last modified: 2016-08-31 09:43
%%================================================
\chapter{系统实现}
\label{cha:system-implementation}

系统实现上，我会同样以三大框架大分，每个模块小分的形式，介绍各个模块在实现上的难点与代码解析。并且以开发和部署两大部分粗略讲解。在讲解开发的过程中，我也会逐个分析每个语言和框架的有点与缺点，为什么时代的前进，后面的框架会越来越吸引人去开发。

\section{开发过程}
\label{sec:development-process}

\subsection{ThinkPHP3.2 框架}

首先使用 ThinkPHP 框架之前，你需要安装配置好 PHP 5.6 之上的环境。PHP 环境的配置相较于 Java 和 Nodejs 与略显麻烦的，但是和 C\# 相比就是速度会明显快很多。PHP 的安装配置与其他语言都不太一样，可以直接傻瓜式安装，不论在 Windows 还是 Linux 都需要一个简单的步骤，添加到环境变量。不过如果你是使用 LAMP 等一种开发包去安装，那会十分简单。

一套开发环境 PHP Apache 和 Mysql 配置完毕后，你就可以开始用一些框架开发网站了。这里我使用的是 ThinkPHP，从官方下载框架并解压，得到一下框架目录结构：

\begin{code}
├── index.php           项目入口文件
├── Application         ThinkPHP 后端 MVC 文件目录
│   ├── Common          公共函数目录
│   ├── Home            Home目录
│   ├── Manager         后台目录
│   ├── Manager_Detail  后台beta目录
│   ├── README.md       框架README文件
│   └── index           
├── db                  供参考的数据库数据
├── ThinkPHP            框架系统目录（可以部署在非 web 目录下面）
├── public              静态文件目录
│   ├── assets          后台样式
│   ├── css             样式目录
│   ├── fonts           字体目录
│   ├── images          静态图片目录
│   ├── js              JS 脚本目录
│   └favicon.png        favicon
├── README.md
└── package.json
\end{code}

Application 目录下除了 Common 目录是用来存放一些公共配置文件以后，其他目录都是以如下目录结构排列，以代表 ThinkPHP 框架中一定的规范

\begin{code}
├─Common       公共文件
├─Conf         这个模块的单独配置
├─Controller   控制器模块
├─Model        模型模块
└─View         视图模块
\end{code}

Common 与 Conf 就不讲了，这类框架与许多框架都十分类似，最重要的一点就是都是 MVC 框架，也就是目录结构中的 Model，Controller，View 三个目录。

先解释下 Model 文件夹，ThinkPHP 是如何与 MySQL 等这类数据库链接数据的呢，Model 的中的 <ModelName>Model.class.php 文件中的写法就很好的解释原因。

\begin{code}
├─MemberModel.class.php    报名人模块
├─ProjectModel.class.php   报名项目模块
└─index.html               空白文件
\end{code}

\begin{code}
// MemberModel.class.php File Content
namespace Home\Model;
use Think\Model;
class MemberModel extends Model{
    protected \$tableName = 'member'; // 对象的数据表
    protected \$_validate = array( /* 省略... */ );
    public function insertM(\$pid, /*省略...*/ )
    { /* 省略... */ }
}
\end{code}

在 ThinkPHP 中，如果表的形式很复杂，可以使用这种模型文件定义，通过定义其\$tableName 表名，可以很方便的操控其表中的数据。当然如果你的模型或者说表结构很简单，你完全可以在控制器直接写：

\begin{code}
\$User = new \Home\Model\UserModel();
\$Info = new \Admin\Model\InfoModel();
// 带参数实例化
\$New  = new \Home\Model\NewModel('blog','think_',\$connection);
\end{code}

在 ThinkPHP 中，可以无需进行任何模型定义。只有在需要封装单独的业务逻辑的时候，模型类才是必须被定义的，因此 ThinkPHP 在模型上有很多的灵活和方便性，让你无需因为表太多而烦恼。

在 MVC 中，除了需要很好的操控数据库那一环，还需要一环去操控视图，也就是这里的 View 视图层。为了不出现代码冗余，通常会利用 HTML 模板引擎去渲染。

\begin{code}
├─<Directory>   对应控制器的模板文件
├─layout.html   模板布局
└─index.html    空白文件
\end{code}

ThinkPHP的模板引擎内置了布局模板功能支持，可以方便的实现模板布局以及布局嵌套功能。layout.html 文件，默认开启 layout 的情况下，是一个父容器。通常的写法如下：

\begin{code}
<header>
</header>
  {__CONTENT__}
<footer>
<footer>
\end{code}

读取 layout 模板之后，会再解析 <Directory>/<相应的模板>.html 模板文件，并把解析后的内容替换到 layout 布局模板文件的 {CONTENT} 特定字符串。

最后就是控制器，这个 MVC 中，最重要的一环，用来控制模板渲染与数据交互的逻辑。在 ThinkPHP 中，它几乎可以与路由相结合，做到很简单的访问。一般来说，ThinkPHP的控制器是一个类，而操作则是控制器类的一个公共方法。下面就是一个典型的控制器类的定义：

\begin{code}
<?php
namespace Home\Controller;
use Think\Controller;
class IndexController extends Controller {
    public function hello(){
        echo 'hello,thinkphp!';
    }
}
\end{code}

Home/IndexController类就代表了 Home 模块下的 Index 控制器，而 hello 操作就是Home/IndexController类的 hello（公共）方法。

当访问 http://serverName/index.php/Home/Index/hello 后会输出：

\begin{code}
hello,thinkphp!
\end{code}

通过 display() 等方法，可以让视图与控制器联系起来，再加上 Model 层的操作，ThinkPHP 就可以做到一般网站开发能做的所有事情。

\subsubsection{报名管理系统}

报名管理系统是一个相较于简单的系统，涉及到数据库中，人员 Member 表与活动 Project 表的增删改查。

其中主要的难点还是整个后台的管理上，比如说只有管理员才能进入后台，否则出现跳转，让他以管理员形式登录。

\begin{code}
if (session('?logineduser')) {
  // 省略
  \$this->display();
} else {
  // 提示
  \$this->error('只有管理员才可以进入,请先登录', 'login');
}
\end{code}

还有就是活动的创建中，需要添加图片到后台，这里利用的是 ThinkPHP 自带的图片文件上传 API 来实现对文件上传保存的功能。

\begin{code}
// 实例化上传类
\$upload = new \Think\Upload();
// 设置附件上传大小
\$upload->maxSize = 3145728;
// 设置附件上传类型
\$upload->exts = array('jpg', 'gif', 'png', 'jpeg');
// 设置附件上传根目录
\$upload->rootPath = './Public/pic/project1/';
// 设置附件上传（子）目录
\$upload->savePath = '';
 // 上传文件
\$info = \$upload->upload();
\end{code}

\subsubsection{考核系统}

考核系统相较于报名系统就复杂许多，首先，它有多种数据需要存储，这也就意味着，你需要建立多张表，同时，每张表之间有着一对多或者一对一的关系，所以，你需要将某些表进行关联。

难点二，你不仅需要做到提交试卷的功能，制作试卷你也需要考虑到出卷人是怎么设计试卷类型的。经过我细致的思考，我总结出一下一套方案去在网页端设计提交出一份试卷。也是处于简单的逻辑考虑。

首先你需要定义一个考试名称吧，还有制定考试的开始时间与结束时间，再加上考试的题型组别，如果可以的话，你可以为你的考试添加上一张个性化的图片，来吸引顾客的目光。一张华丽的图片在设计中是有必要放在某些主题上，充当修饰效果的。

然后，已经进入了这场考试中的组别题型设计，你可以为你的选择题添加一些题目，然后再为你的题目添加几个选项，每个选项的添加都是利用 Ajax 技术去无刷新添加的，可以避免一些无用的数据获取。

在你添加的同时，你可以随时返回题组，添加新的题组，或者在讨论题上新增几个讨论，在选择题中，添加默认的正确答案。最重要的是，当你完成整组试卷的制作，如果你发现问题，你可以在第一时间重新返回题库，进行多次修改。

与此同时，除了选择题，有机器可以帮你判题打分，但是填空题，讨论题是没有这么智能的，所以你需要安排批卷人去审核每套试卷。指定的批卷人可以给定的权限，对每道题进行批改，而且是可以同时批改，可以节约大量时间的。

最后你的试卷的结果分会出现在排行中，你的最终分数将与别人一比高低。

其中试卷的一对多是一个很棘手的问题，当你要获取试卷时，你只能获取一张二维的表格，但是试卷的这个数据结构明显是个树结构，你当然可以想过通过循环去连续获取，不过你根本不知道这张试卷会有多少题型，会有多少题组，更不知道会有多少选择题，每个选择题有多少个选项。所以我们这里利用的是ThinkPHP 提供的关联模型，只需要在 Model 层定义一个简单的 Model 继承自 RelationModel，并在其属性中写上相应关联的表名即可：

\begin{code}
namespace Home\Model;
use Think\Model\RelationModel;
class UserModel extends RelationModel{
    protected \$_link = array(
         '关联1'  =>  array(
             '关联属性1' => '定义',
         )
         '关联2'  =>  HAS_ONE, // 快捷定义
         ...
    );
}
\end{code}

\subsubsection{总结}

php 与 一些 php 框架搭配的网站开发模式虽然在易用性上大大胜出，学习成本也很低，同时 php 也是基于 C++ 开发的语言，其速度，效率也毋庸置疑，是初学者开始学习编程的良好工具。但是它也有很多不足，比如在构建上你需要同时拥有 Apache 软件或者 Nginx 才能去调试网站，局限性也是突出的一点，php 只能开发一些网站，而手机app，应用，还是前端都是 JavaScript ，所以你必须学会一些前端知识，才能真正地去开发一些网站，最后，也是最关键的一点，虽然有 Composer 包管理工具，但 php 本身并不包含此工具，在代码迁移，或者代码构建时会浪费很多时间和空间。

\subsection{Express 与 Pug 框架}

相较于 PHP 语言，Express 与 Pug 都是基于 Nodejs 的，所以在安装 Nodejs 上，会方便许多。其次，nodejs 本身自带了 npm 包管理器，在安装第三方库的时候会十分方便。服务器软件的选择上，不用担心，nodejs本身就自带服务器 API，所以你无需安装一些 Apache 或者 Nginx 软件。数据库方面，你完成可以不用数据库，采用 JSON 文本也可以实现简单的数据库的操作。如果你的项目比较大型，Mysql 等关系型数据库和 Mongodb 非关系型数据库都是非常好的选择。

如果你是一名前端开发者，学习 Nodejs 的成本不是很高，你可以在一天内能搭建出一套网站。这也引申除了全栈工程师为什么会在 JavaScript 程序员中特别多的原因。

Express.js 框架是一个基于 Nodejs 的 Web 应用程序框架，发布于 2010年11月16日，它被称为 nodejs 中标准的服务器框架。由 TJ 大神开发，并迅速成为流行的 Node 服务器框架。

Pug.js 是个高性能的模板引擎，受 Haml 的影响很大，前身是 Jade.js 由于商标问题改为 Pug.js。由于它们共同都是 npm 包，也是网站建设的的贡献者，所以两者都很好安装与互用。

\begin{code}
npm i express
npm i pug
\end{code}

\begin{code}
app.set('view engine', 'pug');
\end{code}

只需要简单的几句可以方便地使用 pug 语法来编写 Html 模板。

\begin{code}
├─controllers   控制器
├─models        模型
├─schemas       表结构
└─views         视图层
    ├─includes  视图中的小插件
    └─pages     视图中的页面
\end{code}

用 Expressjs 搭建的网站目录结构也类似 PHP，采用 MVC 的框架，不过不同的是，我这里用的是非关系型数据库 Mongo，利用 schema 就可以在应用初始化时帮你创建好一些列表结构，这相当于你的数据库与应用也绑定在了一块，十分方便。

\subsection{短信群发平台}

短信群发平台主要是以发送短信为核心。不过发送一个短信并没有你用手机发送这么简单，你需要一个类似通信服务商发送短信的 API，只要得知对方的手机号，和发送内容就可以发送。这需要代码去完成，所以我利用了阿里大于的短信 API 去完成这一部分内容。他们提供了一整套的 API 类似于通信服务商一样的内容，你可以语音，短信，验证码等等一系列内容。

下载阿里大于关于 Nodejs 的 SDK，稍加改装就可以实现简单的发送短信的功能。由于要写的群发短信的功能，这里就要考虑到一些语言会碰到的阻塞性问题，发送一条短信，你需要等阿里大于的服务器返回的结果，然后再去发送，这样会慢许多，通常用异步去解决这类问题。不过 Nodejs 几乎不需要考虑这类情况，Nodejs 本身就是单线程异步的，利用 JavaScript 的回调函数或者 Promise 写法，或者更高级的 Async/await 写法，就可以流畅地去使用异步与同步。 

\subsection{排值班系统}

排值班系统主要是用学生的课表，根据有课无课，或者说有空与没空去安排人员。举一个比较简单的例子，一个社团需要招新了，他们已经有很多成员，成员们也愿意将他们的没课的时间去参加招新的时间上去。一般招新的时间点无非是上午第一大节，第二大节，中午，下午的第三大节，第四大节。所以具体算法就是，先将大家的无课表，记录在一个统一的课表上，然后根据配置，每个值班时间点需要多少人手。按照多劳少排的规则去安排每个人。

\subsection{学习平台}

这里的学习平台主要是为了督促学习用，我在各个平台抓取每个网站的课程信息，写在自己的 Mongo 数据库中，人员信息从报名系统中提取，两者结合就可以实现学习进度情况。除了有爬虫的功能，同时也加入了 NodeBB 论坛，用于学员之类的讨论。社团的通知等等。

\subsection{Vue 与 Koa 前后端分离}

之前讲的 MVC 不管是 PHP 实现还是 Nodejs 实现，都是 Web1.0 的思想，而真正需要发展的，而且目前大公司都在用的都是前后端分离的。后端不用操心前端的事，前端不用管数据安全，服务是如何运行。他们各司其职，它们之间唯一的联系就是 API，后端提供 API 的使用方法，前端用这套 API 去调用即可。一切就变得简单许多，你甚至可以将这套 API 用在各个地方，比如部分开放给公众，用于公开数据，利用大数据的分析，部分可以与手机APP，微信小程序共用。

其中 Vue.js 是国人开发的一款足以与 FaceBook 开发的 React 媲美的前端框架，它简单易于上手，也同样具有庞大的第三方库的支持，甚至有 Gitlab 等一些著名的项目都是基于 Vue 创建的。

Koa.js 是 Tj 大神的另一开山大作，从 2.0 开始 Koa 放弃了老旧的 co.js 依赖，转而支持新技术来保持它异步的功能。你可以看到 Koa2.0 代码十分简单，短小，精悍，它只保留属于服务器的功能，其他功能都通过第三方库来扩建。使开发变得简单高效。

\begin{code}
├─client        前端
│   ├─dist   生产文件
│   └─src    核心文件
└─server        后端
    ├─dist   生产文件
    └─src    核心文件
\end{code}

可以看到在目录构建上，已经将其分别前端与后端两部分，这样能很好的专注于某一部分的开发。

\subsubsection{邮件发送平台}

邮件发送平台主要用于发送邮件，只靠前端是不能完成的，前端只是提供友好的界面，将用户的数据包装发送给后端，后端接收之后，将数据匹配至相应的 API，我这里利用的是 nodemailer 第三方插件，通过邮箱的配置，就可以轻松的发送邮件。

\section{部署过程}

\subsection{Docker 安装}

在 Linux 中安装 Docker 很方便，只要下载对应脚本就可以自动进行安装，同时为了方便使用，在 docker 命令之前不用加上 sudo，你可以将 docker 加入相应的用户组。

此时，Docker 已安装好，如果需要暂停或者启动只需用 systemctl 来启用它即可。当然为了用于 docker-compose 你还需要安装 docker-compose 来实现一键化部署。

\subsection{Docker 配置}

与其说是 docker 配置，还不如说是 docker-compose.yml 文件的配置：

\begin{code}
# 基于 php 这个版本的容器
FROM php:5.6-apache
# 工作目录设定
WORKDIR /var/www/html
# 安装 php 额外的扩展
RUN docker-php-ext-install pdo pdo_mysql
# 开放 80 端口
EXPOSE 80
# 最后执行 apache
CMD apache2-foreground
\end{code}

\begin{code}
version: '2'
services:
  mysql:
    image: mysql:5.7
    container_name: mysql_es
    environment:
      MYSQL_ROOT_PASSWORD: 123456
      MYSQL_DATABASE: es
    volumes:
      - ./db/es.sql:/docker-entrypoint-initdb.d/1.es.sql
  web:
    build: .
    container_name: web_es
    links:
      - mysql
    ports:
      - "8080:80"
    volumes:
      - ./:/var/www/html
\end{code}

这是关于 php 的环境搭建，compose 利用的是两个 docker 容器，容器之间通过端口连接，一个容器通过 Dockerfile 文件定义，另一个是 mysql 容器，是使用官方的。最后只需要一个简单的命令就可以很快的启动，当然这不包括镜像的下载与安装。

